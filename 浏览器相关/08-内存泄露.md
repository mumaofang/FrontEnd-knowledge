# 内存泄露
解释： 应用持续占用不再需要的内存 → GC（垃圾回收）无法回收 → 内存占用持续增长 → 页面卡顿/崩溃
# 那些方式造成
1. 意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。
2. 未清除的定时器：设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
3. DOM 引用未释放：获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。
4. 闭包不当使用：不合理的使用闭包，从而导致某些变量一直被留在内存当中。
5. 未解绑的事件监听：监听了一个事件没有用removeEventListener解绑
6. 缓存无限增长：无限制存储导致内存无线增加，比如while循环一直执行
7. Web Workers 未终止
# 内存泄漏检测方法
1. Chrome DevTools 分析
    内存快照对比：
        打开 DevTools → Memory 标签
        执行操作前拍快照（Snapshot 1）
        执行疑似泄漏操作
        拍第二次快照（Snapshot 2）
        对比 Delta 列查看内存增长
    性能时间线：
        记录 Performance 面板
        观察 JS Heap 折线图是否持续上升
3. 自动化检测工具
        Lighthouse：检测分离的 DOM 节点
        MemLab (Meta 开源)：自动识别 React 泄漏
        LeakSanitizer：Node.js 内存检测