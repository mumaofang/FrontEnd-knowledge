┌───────────────────────┐
│     JavaScript 主线程     │ 
│   Call Stack → Heap     │
└───────────┬─────────────┘
            │
            ▼
┌───────────────────────┐
│   任务队列分层机制         │
│  ┌─────────────────┐  │
│  │ 微任务队列（Microtasks） │← Promise/MutationObserver
│  └─────────────────┘  │
│  ┌─────────────────┐  │
│  │ 宏任务队列（Macrotasks） │← setTimeout/DOM事件/I/O
│  └─────────────────┘  │
│  ┌─────────────────┐  │
│  │ Animation Frames │← requestAnimationFrame
│  └─────────────────┘  │
└───────────┬─────────────┘
            │
            ▼
┌───────────────────────┐
│   事件循环调度器          │
└───────────────────────┘
1. 核心概念

- 调用栈（Call Stack）：同步代码按顺序执行，形成调用栈（后进先出）。

- 任务队列（Task Queue）：异步操作完成后，回调函数被放入队列等待执行。分为：

    - 宏任务队列（Macrotask Queue）：setTimeout、setInterval、DOM 事件、I/O 操作等。

    - 微任务队列（Microtask Queue）：Promise.then()、MutationObserver、queueMicrotask。

- Web APIs：浏览器提供的异步 API（如定时器、AJAX），由底层线程处理。

2. 事件循环流程
- 执行同步代码：调用栈依次执行代码，遇到异步操作交给 Web APIs。

- 处理微任务队列：调用栈清空后，依次执行所有微任务（直到微任务队列为空）。

- 渲染更新（如有需要）：浏览器可能在此阶段进行 UI 渲染。

- 处理宏任务队列：取出一个宏任务执行，回到步骤 2 循环。

3. 执行顺序规则

- 微任务优先级高于宏任务：一轮事件循环中，微任务会在下一个宏任务之前全部执行完毕。

- 同类型任务按入队顺序执行：如多个 setTimeout 按时间到期顺序执行。

3. Node.js 与浏览器的事件循环差异

- 浏览器：以 HTML 标准事件循环为主，微任务在渲染前执行。

- Node.js：采用分阶段的事件循环模型（如 timers、poll、check 阶段），process.nextTick 优先级高于微任务。

4. 优化

    避免阻塞：通过异步处理耗时操作（如网络请求）。

    优化性能：将任务拆分为微任务（如批量 DOM 更新）或宏任务（如延迟计算）。

    控制执行顺序：利用 queueMicrotask 或 setTimeout 调整任务优先级。

    避免在微任务中无限递归生成新的微任务。（饿死宏任务）